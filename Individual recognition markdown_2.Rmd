---
title: "Individual recognition"
output: html_document
date: "2024-07-26"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## Import libraries
```{r}
library(dplyr)
library(stringr)
library(magrittr)
library(readr)
library(purrr)
```


## Get the current directory and the file that contains the names. 

```{r}
setwd("E:/Individual recognition/Individual Recognition R Project")
current_directory <- getwd()
folder_path_events <- paste(getwd(), "/Trial_events_output", sep="")
files_events <- list.files(path=folder_path_events,pattern="\\.tsv$",all.files=FALSE, full.names=FALSE)

file_of_names<- paste(getwd(), "/blind video list_finalised.csv", sep="")
data_frame_of_names <-read.csv(
  file_of_names)
print(data_frame_of_names)

```


## Modify the blind video list_finalised.csv
```{r}

# Read the CSV file
data <- read.csv(file_of_names)

# Modify the Original_code column: replace .MP4 with .csv
data <- data %>%
  mutate(Original_code = str_replace(Original_code, "\\.MP4$", ".tsv"),
         Blind_code = str_c(Blind_code, ".tsv"))
output_file <- paste(getwd(), "/blind_video_list_modified.csv", sep="")
# Write the modified data back to a CSV file
write.csv(data, output_file, row.names = FALSE)
```

## Rename the Blind code files to their original names
```{r}
for (file_path_events in files_events) {
  # Extract the file name without the path
  #print(paste("file path is", file_path))
  file_path_events <- paste("/", file_path_events, sep = "")
  file_path_events <- paste(folder_path_events, file_path_events, sep = "")
  print(paste("file path is", file_path_events))

  file_name_events <- basename(file_path_events)
  #print(paste("file name is", file_name))
  # Check if the file name exists in the Blind_code column
  matched_row <- data %>% filter(Blind_code == file_name_events)
  
  if (nrow(matched_row) == 1) {
    # Get the corresponding Original_code
    new_name_events <- matched_row$Original_code
    
    # Define the new file path
    new_file_path_events <- file.path(folder_path_events, new_name_events)
    # print(paste("new_file_path is", new_file_path))
    # Rename the file
    file.rename(file_path_events, new_file_path_events)
  } else {
    print(paste("No match found for:", file_name_events))
  }
}

```

compare files before and after renaminig, choose random files from the list of names

```{r}
library(dplyr)
library(readr)
library(purrr)

# Define the paths to the two TSV files
file1_path <- "E:/Individual recognition/Individual Recognition R Project/Trial_events_output_1/YQ35.tsv"
file2_path <- "E:/Individual recognition/Individual Recognition R Project/Trial_events_output/Rubezahl_FRF_29102022_1043.tsv"

# Read the TSV files
df1 <- read_tsv(file1_path)
df2 <- read_tsv(file2_path)

# Compare dimensions of the dataframes
if (!all(dim(df1) == dim(df2))) {
  stop("The files have different dimensions and cannot be identical.")
}

# Function to compare two columns with NA handling
compare_columns <- function(col1, col2) {
  equal <- (col1 == col2) | (is.na(col1) & is.na(col2))
  equal[is.na(equal)] <- FALSE  # Handle cases where comparison is NA
  return(equal)
}

# Compare the contents of the dataframes
comparison <- map2(df1, df2, compare_columns)

# Check if all comparisons are TRUE
if (all(map_lgl(comparison, all))) {
  print("The files are identical.")
} else {
  # Identify and print the differing cells
  differing_cells <- bind_rows(
    map2(df1, df2, ~{
      diff <- .x != .y & !(is.na(.x) & is.na(.y))
      diff_rows <- which(diff)
      data.frame(
        Row = diff_rows,
        Column = names(df1)[colnames(df1) == .x],
        File1_Value = .x[diff_rows],
        File2_Value = .y[diff_rows]
      )
    })
  )
  
  print("The files differ at the following cells:")
  print(differing_cells)
}
```


file comparison loop with output results written in a file

```{r}
library(dplyr)
library(readr)
library(purrr)

# Define the paths to the folders
source_folder <- "E:/Individual recognition/Individual Recognition R Project/Trial_events_output"
destination_folder <- "E:/Individual recognition/Individual Recognition R Project/Trial_events_output_1"

# Read the CSV file containing old and new names
name_mapping <- data

# Define the path to the output results file
output_file_path <- "comparison_results.csv"


# Initialize a list to store the comparison results
results_list <- list()

# Function to compare two columns with NA handling
compare_columns <- function(col1, col2) {
  equal <- (col1 == col2) | (is.na(col1) & is.na(col2))
  equal[is.na(equal)] <- FALSE  # Handle cases where comparison is NA
  return(equal)
}

# Function to compare two dataframes and return the differing cells
compare_dataframes <- function(df1, df2) {
  comparison <- map2(df1, df2, compare_columns)
  differing_cells <- bind_rows(
    map2(df1, df2, ~{
      diff <- .x != .y & !(is.na(.x) & is.na(.y))
      diff_rows <- which(diff)
      if (length(diff_rows) > 0) {
        data.frame(
          Row = diff_rows,
          Column = names(df1)[which(names(df1) == .y)],
          File1_Value = .x[diff_rows],
          File2_Value = .y[diff_rows]
        )
      } else {
        NULL
      }
    })
  )
  return(differing_cells)
}

# Iterate through each row of the name mapping
for (i in seq_len(nrow(name_mapping))) {
  old_name <- name_mapping$Original_code[i]
  new_name <- name_mapping$Blind_code[i]

  # Construct the file paths
  source_file_path <- file.path(source_folder, old_name)
  destination_file_path <- file.path(destination_folder, new_name)

  # Check if both files exist
  if (file.exists(source_file_path) & file.exists(destination_file_path)) {
    # Read the TSV files
    df1 <- read_tsv(source_file_path)
    df2 <- read_tsv(destination_file_path)

    # Compare dimensions of the dataframes
    if (!all(dim(df1) == dim(df2))) {
      message <- paste("The files", old_name, "and", new_name, "have different dimensions and cannot be identical.")
      print(message)
      results_list <- append(results_list, list(data.frame(Old_File = old_name, New_File = new_name, Message = message)))
    } else {
      # Compare the contents of the dataframes
      differing_cells <- compare_dataframes(df1, df2)
      if (nrow(differing_cells) == 0) {
        message <- paste("The files", old_name, "and", new_name, "are identical.")
        print(message)
        results_list <- append(results_list, list(data.frame(Old_File = old_name, New_File = new_name, Message = message)))
      } else {
        message <- paste("The files", old_name, "and", new_name, "differ at the following cells:")
        print(message)
        print(differing_cells)
        differing_cells <- mutate(differing_cells, Old_File = old_name, New_File = new_name)
        results_list <- append(results_list, list(differing_cells))
      }
    }
  } else {
    if (!file.exists(source_file_path)) {
      message <- paste("The source file", source_file_path, "does not exist.")
      print(message)
      results_list <- append(results_list, list(data.frame(Old_File = old_name, New_File = new_name, Message = message)))
    }
    if (!file.exists(destination_file_path)) {
      message <- paste("The destination file", destination_file_path, "does not exist.")
      print(message)
      results_list <- append(results_list, list(data.frame(Old_File = old_name, New_File = new_name, Message = message)))
    }
  }
}
```

# Combine all comparison results into a single dataframe

```{r}

results_df <- bind_rows(results_list)

# Write the results to a CSV file
write_csv(results_df, output_file_path)

print(paste("Comparison results have been written to", output_file_path))
```

# rename observation_id as file name
```{r}
library(dplyr)
library(readr)
library(stringr)
library(purrr)

# Define the directory containing the TSV files
input_dir_events <- "E:/Individual recognition/Individual Recognition R Project/Trial_events_output"

# List all TSV files in the directory
tsv_files_events <- list.files(input_dir_events, pattern = "\\.tsv$", full.names = TRUE)

# Function to update the Observation_id column
update_observation_id <- function(file_path) {
  # Read the TSV file
  df_events <- read_tsv(file_path)
  
  # Extract the file name without extension
  file_name_events <- str_remove(basename(file_path), "\\.tsv$")
  
  # Update the Observation_id column
  df_events <- df_events %>%
    mutate(`Observation id`= file_name_events)
  
  # Save the modified dataframe back to the file
  write_tsv(df_events, file_path)
  
  # Print message
  print(paste("Updated Observation_id in file:", file_path))
}

# Apply the function to each TSV file
walk(tsv_files_events, update_observation_id)

```



# load data as a list and bind rowwise

```{r}
library(dplyr)
library(readr)
library(purrr)

# Define the path to the folder containing the TSV files
Trial_events <- "E:/Individual recognition/Individual Recognition R Project/Trial_events_output"

# List all .tsv files in the folder
Trial_events_files <- list.files(path = Trial_events, pattern = "\\.tsv$", full.names = TRUE)

# Read each TSV file into a dataframe and store in a list
Trial_events_a <- map(Trial_events_files, read_tsv)



# Bind all dataframes in the list into a single dataframe
Trial_events_A <- bind_rows(Trial_events_a)

# Save the combined dataframe to a TSV file
write_csv(Trial_events_A, "E:/Individual recognition/Individual Recognition R Project/Trial_events_A.csv")

# Print a message indicating the file has been saved (optional)
print(paste("Combined dataframe has been saved to", "Trial_events_A.csv"))


```


#data check
```{r}
Trial_events_A <- read.csv ("E:/Individual recognition/Individual Recognition R Project/Trial_events_A.csv")

unique(Trial_events_A$Focal)
unique(Trial_events_A$`Observation.id`)

# Check the unique values by two different categories (Focal and Call type)
unique_values <- Trial_events_A %>%
  select("Focal", "Call.type","Treatment") %>%
  distinct()
# Print the unique values
print(unique_values)
```

# rename variables to have no confounding words by including a _ 

```{r}
library(dplyr)
library(stringr)

# Replace periods with underscores in all column names
Trial_events_A <- Trial_events_A %>%
  rename_with(~ str_replace_all(., "\\.", "_"))

# View the updated column names
names(Trial_events_A)


#Trial_events_A <-Trial_events_A %>% 
#  rename("Observation_id"= "Observation id",
  #       "Observation_date" = "Observation date",
 #        "Observation_type" = "Observation type",
 #        "Media_duration_s"="Media duration (s)",
 #        "Image_index" = "Image index",
  #       "Call_type" = "Call type",
  #       "Observation_duration"= "Observation duration",
  #       "Closest_Distance"="Closeset distance",
   #      "Behavioural_Category"= "Behavioral category",
  #       "Modifier_1"= "Modifier #1",
   #      "Behaviour_type"="Behavior type",
   #      "Timestamp" = "Media file name",
   #      "Image_file_path"= "Image file path"
    #     )


Trial_events_A <-Trial_events_A %>% 
  rename(
         "Time_stamp" = "Media_file_name",
        )

write_csv(Trial_events_A, "E:/Individual recognition/Individual Recognition R Project/Trial_events_A.csv")

```


# clean unnecessary columns 

```{r}
# remove columns (Observation_date 2, Description 3, Observation_type 5, Source 6, FPS 8, Date 11, Time 12,Position 13, Site 15, Subject 19, Image_index 25)

# add Behaviour type (state or Point event), and phase (silence beginning, interval, silence end)
Trial_events_A <- read.csv ("E:/Individual recognition/Individual Recognition R Project/Trial_events_A.csv")

for (i in Trial_events_A) {
  
}
Trial_events_B<-Trial_events_A %>% 
  select(-Observation_date,
         -Description,
         -Observation_type,
         -Source,
         -FPS,
         -Date,
         -Time,
         -Position,
         -Site,
         -Image_index,
         -Subject,
         -Comment,
         -Image_file_path
         
         )

summary(Trial_events_B)

write_csv(Trial_events_B, "E:/Individual recognition/Individual Recognition R Project/Trial_events_B.csv")
```


# separate the observation ID into two columns, OBSID and date
# change time format in timestamp column from number of seconds to mm:ss
```{r}
# Load the tidyverse package
library(tidyverse)
Trial_events_B <- read.csv ("E:/Individual recognition/Individual Recognition R Project/Trial_events_B.csv")

# Separate the Observation_id into different parts based on "_" delimiter
Trial_events_C <- Trial_events_B %>%
  separate(Observation_id, into = c("Focal", "Treatment", "Date", "Time"), sep = "_", remove = FALSE) %>%
  mutate(
    Observation_date = as.Date(Date, format = "%d%m%Y"),
    Observation_start = str_replace(Time, "^(\\d{2})(\\d{2})$", "\\1:\\2")
  ) %>%
  select(-Date, -Time)  # Optionally remove the intermediate columns

# Display the updated dataframe
print(Trial_events_C)

write_csv(Trial_events_C, "E:/Individual recognition/Individual Recognition R Project/Trial_events_C.csv")


```

#convert timestamp to mm:ss
```{r}
library(tidyverse)
Trial_events_C <- read.csv ("E:/Individual recognition/Individual Recognition R Project/Trial_events_C.csv")

# Convert Timestamp to mm:ss format
Trial_events_D <- Trial_events_C %>%
  mutate(
    # Calculate minutes and seconds
    minutes = floor(Time_stamp / 60),
    seconds = Time_stamp %% 60,
    # Format minutes and seconds as mm:ss
    Timestamp_mmss = str_c(
      str_pad(minutes, width = 2, pad = "0"),
      ":",
      str_pad(floor(seconds), width = 2, pad = "0")
    )
  )

print(Trial_events_D)

write_csv(Trial_events_D, "E:/Individual recognition/Individual Recognition R Project/Trial_events_D.csv")

```

#convert all durations to mmss
```{r}
library(tidyverse)

Trial_events_C <- read.csv ("E:/Individual recognition/Individual Recognition R Project/Trial_events_C.csv") 

# Function to convert seconds to mm:ss format
convert_to_mmss <- function(seconds) {
  minutes <- floor(seconds / 60)
  seconds <- seconds %% 60
  str_c(
    str_pad(minutes, width = 2, pad = "0"),
    ":",
    str_pad(floor(seconds), width = 2, pad = "0")
  )
}

# Convert Timestamp, observation_duration, and Media_duration to mm:ss format
Trial_events_E <- Trial_events_C %>%
  mutate(
    Timestamp_mmss = convert_to_mmss(Time_stamp),
    Observation_duration_mmss = convert_to_mmss(Observation_duration),
    Media_duration_mmss = convert_to_mmss(Media_duration__s_)
  ) %>%
  select(-Time_stamp, -Observation_duration, -Media_duration__s_) %>%
  rename(
    Time_stamp = Timestamp_mmss,
    Observation_duration = Observation_duration_mmss,
    Media_duration__s_ = Media_duration_mmss
  )

print(Trial_events_E)

write_csv(Trial_events_E, "E:/Individual recognition/Individual Recognition R Project/Trial_events_E.csv")
```

# for trial by event files

#define phases as a) silence beginning, interval and silence end b) Habituation
# c) dishabituation #remove unnecessary columns #for each file, calculate
# 1 - duration of each state event type by phase \# 2 - number of point
#events by type \# 3 - latency of vocal response in each phase \# 4 -
#latency of first gaze at speaker in each phase \# 5 - transition from
#one state to the next in each phase

# define playback phases
```{r}

Trial_events_E <- read.csv ("E:/Individual recognition/Individual Recognition R Project/Trial_events_E.csv")
# Load the necessary library
library(dplyr)

# Print the first few rows of the dataframe to check the contents
head(Trial_events_E)

# Ensure there are no leading/trailing spaces in the columns
Trial_events_F <- Trial_events_E %>%
  mutate(
    Behaviour = trimws(Behaviour),
    Behaviour_type = trimws(Behaviour_type)
  )

# Create the Phase column based on the conditions
Trial_events_F <- Trial_events_F %>%
  mutate(Phase = case_when(
    Time_stamp == "00:00"  ~ "Silence_1", 
    Behaviour == "Hab" & Behaviour_type == "START" ~ "Habituation",
    Behaviour == "Hab" & Behaviour_type == "STOP" ~ "Silence_2",
    Behaviour == "Dhb" & Behaviour_type == "START" ~ "Dishabituation",
      Behaviour == "Dhb" & Behaviour_type == "STOP" ~ "Silence_3",
    TRUE ~ "NA"
  ))

# Print the first few rows to check the result
head(Trial_events_F)
write_csv(Trial_events_F, "E:/Individual recognition/Individual Recognition R Project/Trial_events_F.csv")

```

check that each trial has only one of each phase

```{r}
unique_values2 <- Trial_events_F %>%
  select("Observation_id", "Phase") %>%
  distinct()
print(unique_values2)
```

# i did some corrections to the datasheet manually to make sure the phases 
# covered the full duration of the videos, otherwise I would have needed to redo it # it in BORIS

#calculate point event counts per phase for behaviour and modifier combinations and convert them into rates
# calculate duration of state events by type and phase and
#convert them to a percentage 


# calculate proportion of duration based behaviours that span multiple phases
```{r}
library(dplyr)
library(tidyr)
library(lubridate)  # For time handling functions

# Convert Time_stamp from "mm:ss" format to total seconds and handle NA in Modifier
Trial_events_G <- Trial_events_G %>%
  mutate(
    # Convert mm:ss format to seconds
    Time_stamp = ms(Time_stamp),  # Converts "mm:ss" format to Period object (minutes and seconds)
    Time_stamp_seconds = as.numeric(Time_stamp, units = "seconds"),  # Convert Period to numeric seconds
    # Replace NA in Modifier with "None" to handle missing values
    Modifier = ifelse(is.na(Modifier), "None", Modifier)
  )

# Step 1: Calculate total duration of each time-based behaviour across all phases
total_duration_summary <- Trial_events_G %>%
  filter(Behaviour_type %in% c("START", "STOP")) %>%
  group_by(Observation_id, Behaviour, Modifier) %>%
  arrange(Observation_id, Behaviour, Modifier, Time_stamp_seconds) %>%
  mutate(Duration_s = if_else(
    Behaviour_type == "STOP",
    Time_stamp_seconds - lag(Time_stamp_seconds),  # Calculate duration in seconds between STOP and START
    NA_real_
  )) %>%
  filter(!is.na(Duration_s)) %>%
  summarise(Total_Duration_s = sum(Duration_s), .groups = "drop") %>%
  # Pivot wider to have one column per unique behaviour-modifier combination
  pivot_wider(names_from = c(Behaviour, Modifier), 
              values_from = Total_Duration_s, 
              values_fill = list(Total_Duration_s = 0),  # Fill missing values with 0
              names_prefix = "Total_Duration_")

# Step 2: Calculate duration of each time-based behaviour per modifier per phase
duration_by_phase <- Trial_events_G %>%
  filter(Behaviour_type %in% c("START", "STOP")) %>%
  group_by(Observation_id, Phase, Behaviour, Modifier) %>%
  arrange(Observation_id, Phase, Behaviour, Modifier, Time_stamp_seconds) %>%
  mutate(Duration_s = if_else(
    Behaviour_type == "STOP",
    Time_stamp_seconds - lag(Time_stamp_seconds),  # Calculate duration in seconds between STOP and START
    NA_real_
  )) %>%
  filter(!is.na(Duration_s)) %>%
  summarise(Duration_in_Phase_s = sum(Duration_s), .groups = "drop") %>%
  # Pivot wider to have one column per unique behaviour-modifier-phase combination
  pivot_wider(names_from = c(Behaviour, Modifier), 
              values_from = Duration_in_Phase_s, 
              values_fill = list(Duration_in_Phase_s = 0),  # Fill missing values with 0
              names_prefix = "Phase_Duration_")

# Step 3: Calculate the proportion of the total duration that occurs in each phase
proportion_summary <- duration_by_phase %>%
  left_join(total_duration_summary, by = c("Observation_id", "Behaviour", "Modifier")) %>%
  mutate(across(starts_with("Phase_Duration_"), 
                ~ ./Total_Duration_,  # Calculate the proportion
                .names = "Proportion_{.col}")) %>%
  select(-Total_Duration_)  # Remove Total_Duration column if not needed

# Create a base data frame of unique Observation_ids and Phases
observation_summary <- Trial_events_G %>%
  distinct(Observation_id, Phase)

# Combine all summaries with the base dataframe
final_dataset <- observation_summary %>%
  left_join(duration_by_phase, by = c("Observation_id", "Phase")) %>%
  left_join(total_duration_summary, by = c("Observation_id")) %>%
  left_join(proportion_summary, by = c("Observation_id", "Phase"))

# Replace any remaining NAs with 0 to ensure completeness
final_dataset <- final_dataset %>%
  mutate(across(starts_with("Phase_Duration_"), ~ replace_na(., 0))) %>%
  mutate(across(starts_with("Proportion_"), ~ replace_na(., 0))) %>%
  mutate(across(starts_with("Total_Duration_"), ~ replace_na(., 0)))

# View the final dataset
print("Final Dataset:")
print(head(final_dataset))

```


### attempt at combining all previous three parts (point events, duration based, proportions)
```{r}


Trial_events_G <- read.csv ("E:/Individual recognition/Individual Recognition R Project/Trial_events_G.csv")

library(dplyr)
library(tidyr)
library(lubridate)

# Convert Time_stamp from "mm:ss" format to seconds and handle NA in Modifier
Trial_events_G <- Trial_events_G %>%
  mutate(
    Time_stamp = ms(Time_stamp),
    Time_stamp_seconds = as.numeric(Time_stamp, units = "seconds"),
    Modifier = ifelse(is.na(Modifier), "None", Modifier)
  )

# List of all phases
all_phases <- c("Silence_1", "Habituation", "Silence_2", "Dishabituation", "Silence_3")

# Step 1: Count point events by phase and calculate the rate per phase duration
point_events_summary <- Trial_events_G %>%
  filter(Behaviour_type == "POINT") %>%
  group_by(Observation_id, Phase, Behaviour, Behavioural_category, Modifier) %>%
  summarise(Point_Event_Count = n(), .groups = "drop") %>%
  ungroup() %>%
  complete(Observation_id, Phase = all_phases, fill = list(Point_Event_Count = 0))

write_csv(point_events_summary, "E:/Individual recognition/Individual Recognition R Project/point_events_summary.csv")

# Step 2: Calculate duration of each time-based behaviour per modifier per phase
duration_by_phase <- Trial_events_G %>%
  filter(Behaviour_type %in% c("START", "STOP")) %>%
  group_by(Observation_id, Phase, Behaviour, Behavioural_category, Modifier) %>%
  arrange(Observation_id, Phase, Behaviour, Modifier, Time_stamp_seconds) %>%
  mutate(Duration_s = if_else(
    Behaviour_type == "STOP",
    Time_stamp_seconds - lag(Time_stamp_seconds),
    NA_real_
  )) %>%
  filter(!is.na(Duration_s)) %>%
  summarise(Duration_in_Phase_s = sum(Duration_s, na.rm = TRUE), .groups = "drop") %>%
  ungroup() %>%
  complete(Observation_id, Phase = all_phases, Behaviour,Behavioural_category, Modifier, fill = list(Duration_in_Phase_s = 0))

# Calculate phase duration
phase_duration <- Trial_events_G %>%
  group_by(Observation_id, Phase) %>%
  summarise(Phase_Duration_s = max(Time_stamp_seconds, na.rm = TRUE), .groups = "drop") %>%
  ungroup() %>%
  complete(Observation_id, Phase = all_phases, fill = list(Phase_Duration_s = 0))

# Combine point event counts with phase duration to calculate rates
point_events_with_rate <- point_events_summary %>%
  left_join(phase_duration, by = c("Observation_id", "Phase")) %>%
  mutate(Rate = ifelse(Phase_Duration_s > 0, Point_Event_Count / Phase_Duration_s, 0))

write_csv(point_events_with_rate , "E:/Individual recognition/Individual Recognition R Project/point_events_with_rate .csv")

# Calculate the total duration for each behaviour-modifier combination across all phases
total_duration_summary <- duration_by_phase %>%
  group_by(Observation_id, Behaviour, Behavioural_category, Modifier) %>%
  summarise(Total_Duration_s = sum(Duration_in_Phase_s, na.rm = TRUE), .groups = "drop")

write_csv(total_duration_summary , "E:/Individual recognition/Individual Recognition R Project/total_duration_summary .csv")


# Calculate the proportion of the total duration that occurs in each phase
proportion_summary <- duration_by_phase %>%
  left_join(total_duration_summary, by = c("Observation_id", "Behaviour","Behavioural_category", "Modifier")) %>%
  mutate(Proportion = ifelse(Total_Duration_s > 0, Duration_in_Phase_s / Total_Duration_s, NA))

write_csv(proportion_summary , "E:/Individual recognition/Individual Recognition R Project/proportion_summary .csv")


# Combine point event counts, durations, and proportions into the final dataset
final_dataset <- phase_duration %>%
  full_join(point_events_with_rate, by = c("Observation_id", "Phase")) %>%
  full_join(duration_by_phase, by = c("Observation_id", "Phase", "Behaviour","Behavioural_category", "Modifier")) %>%
  full_join(proportion_summary, by = c("Observation_id", "Phase", "Behaviour","Behavioural_category", "Modifier"))

# Rename columns for clarity
final_dataset <- final_dataset %>%
  rename(
    Phase_Duration_s = Phase_Duration_s.x,
    Duration_in_Phase_s = Duration_in_Phase_s.x,
    Point_Event_Count = Point_Event_Count,
    Rate = Rate,
    Total_Duration_s = Total_Duration_s,
    Proportion = Proportion
  )

# Replace any remaining NAs with 0 to ensure completeness
final_dataset <- final_dataset %>%
  mutate(across(where(is.numeric), ~ replace_na(., 0)))
#remove duplicate duration in seconds column resulting from merging the two dataframes
final_dataset <- final_dataset %>%
  select(-Duration_in_Phase_s.y)

# View the final dataset
print("Final Dataset:")
print(head(final_dataset))


write_csv(final_dataset, "E:/Individual recognition/Individual Recognition R Project/final_dataset_3.csv")
```




# updated code for calculating phase durations correctly by subtraction
#ran the point events correctly but not the rest - discard if modification runs well


```{r}

Trial_events_G <- read.csv ("E:/Individual recognition/Individual Recognition R Project/Trial_events_G.csv")

# Load necessary libraries
library(dplyr)
library(tidyr)

# Function to convert mm:ss to seconds
convert_to_seconds <- function(time_str) {
  if (is.na(time_str)) return(NA)
  parts <- unlist(strsplit(time_str, ":"))
  if (length(parts) != 2) return(NA)
  as.numeric(parts[1]) * 60 + as.numeric(parts[2])
}

# Step 1: Calculate Phase Duration Correctly using mm:ss format subtraction
phase_duration_corrected <- Trial_events_G %>%
  # Convert Time_stamp to numeric seconds
  mutate(Time_seconds = sapply(Time_stamp, convert_to_seconds)) %>%
  group_by(Observation_id, Phase) %>%
  summarise(
    # Find the first and last timestamp within each phase
    Phase_Start = first(Time_seconds),
    Phase_End = last(Time_seconds),
    # Calculate the phase duration by directly subtracting timestamps in seconds
    Phase_Duration_s = Phase_End - Phase_Start,
    .groups = "drop"
  )

# View the phase duration summary
View(phase_duration_corrected)

# Step 2: Merge Phase Durations Back into the Main Dataset
Trial_events_G <- Trial_events_G %>%
  # Convert Time_stamp to numeric seconds for merging
  mutate(Time_seconds = sapply(Time_stamp, convert_to_seconds)) %>%
  left_join(phase_duration_corrected, by = c("Observation_id", "Phase"))

# Step 3: Calculate Counts of Point Events
point_events_summary <- Trial_events_G %>%
  filter(Behaviour_type == "POINT") %>%
  group_by(Observation_id, Phase, Behaviour, Modifier) %>%
  summarise(Point_Count = n(), .groups = "drop")

# View the point events summary
View(point_events_summary)

# Step 4: Calculate Durations of Time-Based Behaviours
# Summarize time-based behaviours within each phase
duration_by_phase <- Trial_events_G %>%
  filter(Behaviour_type %in% c("START", "STOP")) %>%
  group_by(Observation_id, Phase, Behaviour, Behavioural_category, Modifier) %>%
  summarise(
    Duration_in_Phase_s = sum(as.numeric(difftime(
      Time_seconds[Behaviour_type == "STOP"], 
      Time_seconds[Behaviour_type == "START"], units = "secs"
    ))),
    .groups = "drop"
  )

# View the duration by phase summary
View(duration_by_phase)

# Step 5: Calculate Proportions of Time-Based Behaviours Spanning Multiple Phases
proportion_summary <- Trial_events_G %>%
  filter(Behaviour_type %in% c("START", "STOP")) %>%
  group_by(Observation_id, Behaviour, Behavioural_category, Modifier) %>%
  summarise(
    Total_Duration_s = sum(as.numeric(difftime(
      Time_seconds[Behaviour_type == "STOP"], 
      Time_seconds[Behaviour_type == "START"], units = "secs"
    ))),
    .groups = "drop"
  ) %>%
  left_join(duration_by_phase, by = c("Observation_id", "Behaviour", "Behavioural_category", "Modifier")) %>%
  mutate(Proportion = Duration_in_Phase_s / Total_Duration_s)

# View the proportion summary
View(proportion_summary)

# Step 6: Combine All Results into One Final Analysis Dataset
final_dataset <- Trial_events_G %>%
  select(Observation_id, Phase) %>%
  distinct() %>%
  left_join(point_events_summary, by = c("Observation_id", "Phase")) %>%
  left_join(duration_by_phase, by = c("Observation_id", "Phase", "Behaviour", "Behavioural_category", "Modifier")) %>%
  left_join(proportion_summary, by = c("Observation_id", "Behaviour", "Behavioural_category", "Modifier")) %>%
  # Removing duplicate or redundant columns if any exist
  select(-matches("\\.y$")) # This line removes columns with ".y" suffix from duplicates

# View the final dataset
View(final_dataset)

write_csv(final_dataset, "E:/Individual recognition/Individual Recognition R Project/final_dataset_4.csv")

```

# updated for both types of behaviours, calculating phase by subtractions

```{r}

Trial_events_G <- read.csv ("E:/Individual recognition/Individual Recognition R Project/Trial_events_G.csv")

library(dplyr)
library(tidyr)
library(purrr)  # For map functions
library(lubridate)  # For handling time formats

# Function to convert mm:ss to seconds
convert_to_seconds <- function(time_str) {
  if (is.na(time_str)) return(NA)
  parts <- unlist(strsplit(time_str, ":"))
  if (length(parts) != 2) return(NA)
  as.numeric(parts[1]) * 60 + as.numeric(parts[2])
}

# Convert Time_stamp to seconds
Trial_events_G <- Trial_events_G %>%
  mutate(Time_seconds = sapply(Time_stamp, convert_to_seconds))

# Calculate Phase Duration
phase_duration_corrected <- Trial_events_G %>%
  group_by(Observation_id, Phase) %>%
  summarise(
    Phase_Start = min(Time_seconds, na.rm = TRUE),
    Phase_End = max(Time_seconds, na.rm = TRUE),
    Phase_Duration_s = Phase_End - Phase_Start,
    .groups = "drop"
  )

# Merge Phase Durations Back into the Main Dataset
Trial_events_G <- Trial_events_G %>%
  left_join(phase_duration_corrected, by = c("Observation_id", "Phase"))

# Calculate Duration of Time-Based Behaviours
time_based_behaviours <- Trial_events_G %>%
  filter(Behaviour_type %in% c("START", "STOP")) %>%
  group_by(Observation_id, Phase, Behaviour, Behavioural_category, Modifier) %>%
  arrange(Observation_id, Phase, Behaviour, Modifier, Time_seconds) %>%
  nest() %>%  # Nest the data to work with each group separately
  mutate(
    Duration_in_Phase_s = map_dbl(data, function(df) {
      start_times <- df$Time_seconds[df$Behaviour_type == "START"]
      stop_times <- df$Time_seconds[df$Behaviour_type == "STOP"]
      if (length(start_times) == 0 | length(stop_times) == 0) return(NA)
      
      durations <- sapply(start_times, function(start_time) {
        matching_stops <- stop_times[stop_times > start_time]
        if (length(matching_stops) == 0) return(NA)
        matching_stops[1] - start_time  # Take the first stop time that is after the start
      })
      
      sum(durations, na.rm = TRUE)
    })
  ) %>%
  select(-data)  # Remove the nested data column

# Check for Duration_in_Phase_s in the intermediate dataset
print("Checking intermediate dataset for Duration_in_Phase_s:")
print(head(time_based_behaviours))

# Calculate Proportions of Time-Based Behaviours Spanning Multiple Phases
proportion_summary <- time_based_behaviours %>%
  group_by(Observation_id, Behaviour, Behavioural_category, Modifier) %>%
  summarise(
    Total_Duration_s = sum(Duration_in_Phase_s, na.rm = TRUE),
    .groups = "drop"
  )

# Check for Total_Duration_s in the intermediate dataset
print("Checking intermediate dataset for Total_Duration_s:")
print(head(proportion_summary))

# Combine All Results into One Final Analysis Dataset
final_dataset <- Trial_events_G %>%
  select(Observation_id, Phase) %>%
  distinct() %>%
  left_join(point_events_summary, by = c("Observation_id", "Phase")) %>%
  left_join(time_based_behaviours, by = c("Observation_id", "Phase", "Behaviour", "Behavioural_category", "Modifier")) %>%
  left_join(proportion_summary, by = c("Observation_id", "Behaviour",  "Modifier")) %>%
  # Remove columns with ".y" suffix from duplicates
  select(-matches("\\.y$"))

# View the final dataset
View(final_dataset)


```

# VERSION THAT WORKED - contains both point and time based behaviours with phases calculated by subtracting timestamps and proportions of time based behaviours spanning multiple phases calculated. joining did not work correctly but the dataframes are fine


```{r}

Trial_events_G <- read.csv ("E:/Individual recognition/Individual Recognition R Project/Trial_events_G.csv")

library(dplyr)
library(tidyr)
library(lubridate)

# Convert Time_stamp to seconds
convert_to_seconds <- function(time_str) {
  if (is.na(time_str)) return(NA)
  parts <- unlist(strsplit(time_str, ":"))
  if (length(parts) != 2) return(NA)
  as.numeric(parts[1]) * 60 + as.numeric(parts[2])
}

# Convert Time_stamp to seconds
Trial_events_G <- Trial_events_G %>%
  mutate(Time_seconds = sapply(Time_stamp, convert_to_seconds))

# Calculate Phase Duration
phase_duration_corrected <- Trial_events_G %>%
  group_by(Observation_id, Phase) %>%
  summarise(
    Phase_Start = min(Time_seconds, na.rm = TRUE),
    Phase_End = max(Time_seconds, na.rm = TRUE),
    Phase_Duration_s = Phase_End - Phase_Start,
    .groups = "drop"
  )

# Merge Phase Durations Back into the Main Dataset
Trial_events_G <- Trial_events_G %>%
  left_join(phase_duration_corrected, by = c("Observation_id", "Phase"))

# Calculate Point Events Summary
point_events_summary <- Trial_events_G %>%
  filter(Behaviour_type == "POINT") %>%
  group_by(Observation_id, Phase, Behaviour, Behavioural_category, Modifier) %>%
  summarise(
    Count = n(),
    Phase_Duration_s = first(Phase_Duration_s),  # Include Phase Duration in the summary
    Rate_per_Phase_Duration = Count / Phase_Duration_s,
    .groups = "drop"
  )

# Calculate Duration of Time-Based Behaviours
time_based_behaviours <- Trial_events_G %>%
  filter(Behaviour_type %in% c("START", "STOP")) %>%
  group_by(Observation_id, Phase, Behaviour, Behavioural_category, Modifier) %>%
  arrange(Observation_id, Phase, Behaviour, Modifier, Time_seconds) %>%
  nest() %>%  # Nest the data to work with each group separately
  mutate(
    Duration_in_Phase_s = map_dbl(data, function(df) {
      start_times <- df$Time_seconds[df$Behaviour_type == "START"]
      stop_times <- df$Time_seconds[df$Behaviour_type == "STOP"]
      if (length(start_times) == 0 | length(stop_times) == 0) return(NA)
      
      durations <- sapply(start_times, function(start_time) {
        matching_stops <- stop_times[stop_times > start_time]
        if (length(matching_stops) == 0) return(NA)
        matching_stops[1] - start_time  # Take the first stop time that is after the start
      })
      
      sum(durations, na.rm = TRUE)
    })
  ) %>%
  select(-data)  # Remove the nested data column

# Calculate Proportions of Time-Based Behaviours Spanning Multiple Phases
proportion_summary <- time_based_behaviours %>%
  group_by(Observation_id, Behaviour, Behavioural_category, Modifier) %>%
  summarise(
    Total_Duration_s = sum(Duration_in_Phase_s, na.rm = TRUE),
    .groups = "drop"
  )

# Combine All Results into One Final Analysis Dataset
final_dataset <- Trial_events_G %>%
  select(Observation_id, Phase) %>%
  distinct() %>%
  left_join(point_events_summary, by = c("Observation_id", "Phase")) %>%
  left_join(time_based_behaviours, by = c("Observation_id", "Phase", "Behaviour", "Behavioural_category", "Modifier")) %>%
  left_join(proportion_summary, by = c("Observation_id", "Behaviour",  "Modifier")) %>%
  # Remove columns with ".y" suffix from duplicates
  select(-matches("\\.y$"))

# View the final dataset
View(final_dataset)

write_csv(final_dataset, "E:/Individual recognition/Individual Recognition R Project/final_dataset_5.csv")



```


#data checks


```{r}
# 1. Check Point Event Counts
# Sum the counts of point events from Trial_events_G and compare with final_dataset
point_check <- Trial_events_G %>%
  filter(Behaviour_type == "POINT") %>%
  group_by(Observation_id, Phase, Behaviour, Behavioural_category, Modifier) %>%
  summarize(Original_Count = n(), .groups = 'drop') %>%
  # Join with the final dataset to compare
  left_join(final_dataset, by = c("Observation_id", "Phase", "Behaviour", "Behavioural_category", "Modifier")) %>%
  mutate(Match = Original_Count == Point_Event_Count)

# Print rows where counts do not match
print("Point Event Count Discrepancies:")
point_check %>% filter(!Match)

# 2. Check Duration Summaries for Time-Based Behaviours
# Calculate the duration directly from Trial_events_G for verification
duration_check <- Trial_events_G %>%
  mutate(Time_stamp = ms(Time_stamp)) %>%
  group_by(Observation_id, Phase, Behaviour, Behavioural_category, Modifier) %>%
  mutate(Duration_s = if_else(
    Behaviour_type == "STOP",
    as.numeric(Time_stamp - lag(Time_stamp, default = first(Time_stamp)), units = "secs"),
    0
  )) %>%
  summarize(Original_Duration_s = sum(Duration_s, na.rm = TRUE), .groups = 'drop') %>%
  # Join with the final dataset to compare
  left_join(final_dataset, by = c("Observation_id", "Phase", "Behaviour", "Behavioural_category", "Modifier")) %>%
  mutate(Match = Original_Duration_s == Duration_in_Phase_s)

# Print rows where durations do not match
print("Duration Discrepancies:")
duration_check %>% filter(!Match)

# 3. Check Phase Duration Calculation
# Calculate phase duration directly from the original data
phase_duration_check <- Trial_events_G %>%
  mutate(Time_stamp = ms(Time_stamp)) %>%
  group_by(Observation_id, Phase) %>%
  summarize(Original_Phase_Duration_s = as.numeric(max(Time_stamp) - min(Time_stamp), units = "secs"), .groups = 'drop') %>%
  # Join with the final dataset to compare
  left_join(final_dataset, by = c("Observation_id", "Phase")) %>%
  mutate(Match = Original_Phase_Duration_s == Phase_Duration_s)

# Print rows where phase durations do not match
print("Phase Duration Discrepancies:")
phase_duration_check %>% filter(!Match)

# 4. Check Proportion Calculations
# Verify if the proportion aligns with the phase durations
proportion_check <- final_dataset %>%
  mutate(Calculated_Proportion = Duration_in_Phase_s / Total_Duration_s) %>%
  mutate(Match = Proportion == Calculated_Proportion)

# Print rows where proportions do not match
print("Proportion Calculation Discrepancies:")
proportion_check %>% filter(!Match)


write_csv(proportion_check, "E:/Individual recognition/Individual Recognition R Project/proportion_check.csv")
```






# for time budget files




## Get the current directory and the file that contains the names. 

```{r}
setwd("E:/Individual recognition/Individual Recognition R Project")
current_directory <- getwd()
folder_path_budget <- paste(getwd(), "/Time budget output", sep="")
files_budget <- list.files(path=folder_path_budget, pattern="\\.tsv$",all.files=FALSE, 
    full.names=FALSE)

file_of_names <- paste(getwd(), "/blind video list_finalised.csv", sep="")
data_frame_of_names <-read.csv(
  file_of_names)
print(data_frame_of_names)

```



# rename observation_id as file name
```{r}



library(dplyr)
library(readr)
library(stringr)
library(purrr)

# Define the directory containing the TSV files
input_dir_budget <- "E:/Individual recognition/Individual Recognition R Project/Time budget output"

# List all TSV files in the directory
tsv_files_budget <- list.files(input_dir, pattern = "\\.tsv$", full.names = TRUE)

# Function to update the Observation_id column
update_observation_id <- function(file_path_budget) {
  # Read the TSV file
  df_budget <- read_tsv(file_path_budget)
  
  # Extract the file name without extension
  file_name_budget <- str_remove(basename(file_path_budget), "\\.tsv$")
  
  # Update the Observation_id column
  df_budget <- df_budget %>%
    mutate("Observation id" = file_name_budget)
  
  # Save the modified dataframe back to the file
  write_tsv(df_budget, file_path_budget)
  
  # Print message
  print(paste("Updated Observation_id in file:", file_path_budget))
}

# Apply the function to each TSV file
walk(tsv_files_budget, update_observation_id)

```


## Rename the Blind code files to their original names
```{r}
for (file_path_budget in files_budget) {
  # Extract the file name without the path
  #print(paste("file path is", file_path))
  file_path_budget <- paste("/", file_path_budget, sep = "")
  file_path_budget <- paste(folder_path_budget, file_path_budget, sep = "")
  print(paste("file path is", file_path_budget))

  file_name_budget <- basename(file_path_budget)
  #print(paste("file name is", file_name))
  # Check if the file name exists in the Blind_code column
  matched_row <- data %>% filter(Blind_code == file_name_budget)
  
  if (nrow(matched_row) == 1) {
    # Get the corresponding Original_code
    new_name_budget <- matched_row$Original_code
    
    # Define the new file path
    new_file_path_budget <- file.path(folder_path_budget, new_name_budget)
    # print(paste("new_file_path is", new_file_path))
    # Rename the file
    file.rename(file_path_budget, new_file_path_budget)
  } else {
    print(paste("No match found for:", file_name_budget))
  }
}


```

compare files before and after renaminig, choose random files from the list of names

```{r}
library(dplyr)
library(readr)
library(purrr)

# Define the paths to the two TSV files
file1_path <- "E:/Individual recognition/Individual Recognition R Project/Trial events output1/YQ35.tsv"
file2_path <- "E:/Individual recognition/Individual Recognition R Project/Trial events output/Rubezahl_FRF_29102022_1043.tsv"

# Read the TSV files
df1 <- read_tsv(file1_path)
df2 <- read_tsv(file2_path)

# Compare dimensions of the dataframes
if (!all(dim(df1) == dim(df2))) {
  stop("The files have different dimensions and cannot be identical.")
}

# Function to compare two columns with NA handling
compare_columns <- function(col1, col2) {
  equal <- (col1 == col2) | (is.na(col1) & is.na(col2))
  equal[is.na(equal)] <- FALSE  # Handle cases where comparison is NA
  return(equal)
}

# Compare the contents of the dataframes
comparison <- map2(df1, df2, compare_columns)

# Check if all comparisons are TRUE
if (all(map_lgl(comparison, all))) {
  print("The files are identical.")
} else {
  # Identify and print the differing cells
  differing_cells <- bind_rows(
    map2(df1, df2, ~{
      diff <- .x != .y & !(is.na(.x) & is.na(.y))
      diff_rows <- which(diff)
      data.frame(
        Row = diff_rows,
        Column = names(df1)[colnames(df1) == .x],
        File1_Value = .x[diff_rows],
        File2_Value = .y[diff_rows]
      )
    })
  )
  
  print("The files differ at the following cells:")
  print(differing_cells)
}
```


file comparison loop with output results written in a file

```{r}
library(dplyr)
library(readr)
library(purrr)

# Define the paths to the folders
source_folder <- "E:/Individual recognition/Individual Recognition R Project/Trial events output"
destination_folder <- "E:/Individual recognition/Individual Recognition R Project/Trial events output_Orig"

# Read the CSV file containing old and new names
name_mapping <- data

# Define the path to the output results file
output_file_path <- "comparison_results.csv"


# Initialize a list to store the comparison results
results_list <- list()

# Function to compare two columns with NA handling
compare_columns <- function(col1, col2) {
  equal <- (col1 == col2) | (is.na(col1) & is.na(col2))
  equal[is.na(equal)] <- FALSE  # Handle cases where comparison is NA
  return(equal)
}

# Function to compare two dataframes and return the differing cells
compare_dataframes <- function(df1, df2) {
  comparison <- map2(df1, df2, compare_columns)
  differing_cells <- bind_rows(
    map2(df1, df2, ~{
      diff <- .x != .y & !(is.na(.x) & is.na(.y))
      diff_rows <- which(diff)
      if (length(diff_rows) > 0) {
        data.frame(
          Row = diff_rows,
          Column = names(df1)[which(names(df1) == .y)],
          File1_Value = .x[diff_rows],
          File2_Value = .y[diff_rows]
        )
      } else {
        NULL
      }
    })
  )
  return(differing_cells)
}

# Iterate through each row of the name mapping
for (i in seq_len(nrow(name_mapping))) {
  old_name <- name_mapping$Original_code[i]
  new_name <- name_mapping$Blind_code[i]

  # Construct the file paths
  source_file_path <- file.path(source_folder, old_name)
  destination_file_path <- file.path(destination_folder, new_name)

  # Check if both files exist
  if (file.exists(source_file_path) & file.exists(destination_file_path)) {
    # Read the TSV files
    df1 <- read_tsv(source_file_path)
    df2 <- read_tsv(destination_file_path)

    # Compare dimensions of the dataframes
    if (!all(dim(df1) == dim(df2))) {
      message <- paste("The files", old_name, "and", new_name, "have different dimensions and cannot be identical.")
      print(message)
      results_list <- append(results_list, list(data.frame(Old_File = old_name, New_File = new_name, Message = message)))
    } else {
      # Compare the contents of the dataframes
      differing_cells <- compare_dataframes(df1, df2)
      if (nrow(differing_cells) == 0) {
        message <- paste("The files", old_name, "and", new_name, "are identical.")
        print(message)
        results_list <- append(results_list, list(data.frame(Old_File = old_name, New_File = new_name, Message = message)))
      } else {
        message <- paste("The files", old_name, "and", new_name, "differ at the following cells:")
        print(message)
        print(differing_cells)
        differing_cells <- mutate(differing_cells, Old_File = old_name, New_File = new_name)
        results_list <- append(results_list, list(differing_cells))
      }
    }
  } else {
    if (!file.exists(source_file_path)) {
      message <- paste("The source file", source_file_path, "does not exist.")
      print(message)
      results_list <- append(results_list, list(data.frame(Old_File = old_name, New_File = new_name, Message = message)))
    }
    if (!file.exists(destination_file_path)) {
      message <- paste("The destination file", destination_file_path, "does not exist.")
      print(message)
      results_list <- append(results_list, list(data.frame(Old_File = old_name, New_File = new_name, Message = message)))
    }
  }
}

# Combine all results into a single dataframe
results_df <- bind_rows(results_list)

# Write the results to a CSV file
write_csv(results_df, output_file_path)

print(paste("Comparison results have been written to", output_file_path))
```

# rename observation_id as file name
```{r}
library(dplyr)
library(readr)
library(stringr)
library(purrr)

# Define the directory containing the TSV files
input_dir_events <- "E:/Individual recognition/Individual Recognition R Project/Trial events output"

# List all TSV files in the directory
tsv_files_events <- list.files(input_dir_events, pattern = "\\.tsv$", full.names = TRUE)

# Function to update the Observation_id column
update_observation_id <- function(file_path) {
  # Read the TSV file
  df_events <- read_tsv(file_path)
  
  # Extract the file name without extension
  file_name_events <- str_remove(basename(file_path), "\\.tsv$")
  
  # Update the Observation_id column
  df_events <- df_events %>%
    mutate(`Observation id`= file_name_events)
  
  # Save the modified dataframe back to the file
  write_tsv(df_events, file_path)
  
  # Print message
  print(paste("Updated Observation_id in file:", file_path))
}

# Apply the function to each TSV file
walk(tsv_files_events, update_observation_id)

```



# load data as a list and bind rowwise

```{r}
library(dplyr)
library(readr)
library(purrr)

# Define the path to the folder containing the TSV files
Trial_events <- "E:/Individual recognition/Individual Recognition R Project/Trial events output"

# List all .tsv files in the folder
Trial_events_files <- list.files(path = Trial_events, pattern = "\\.tsv$", full.names = TRUE)

# Read each TSV file into a dataframe and store in a list
Trial_events_a <- map(Trial_events_files, read_tsv)



# Bind all dataframes in the list into a single dataframe
Trial_events_A <- bind_rows(Trial_events_a)

# Save the combined dataframe to a TSV file
write_csv(Trial_events_A, "E:/Individual recognition/Individual Recognition R Project/Trial_events_A.csv")

# Print a message indicating the file has been saved (optional)
print(paste("Combined dataframe has been saved to", "Trial_events_A.csv"))


```


#data check
```{r}
unique(Trial_events_A$Focal)
unique(Trial_events_A$`Observation id`)

# Check the unique values by two different categories (Focal and Call type)
unique_values <- Trial_events_A %>%
  select("Focal", "Call type","Treatment") %>%
  distinct()
# Print the unique values
print(unique_values)
```

# rename variables to have no confounding words by including a _ 

```{r}


Trial_events_A <-Trial_events_A %>% 
  rename("Observation_id"= "Observation id",
         "Observation_date" = "Observation date",
         "Observation_type" = "Observation type",
         "Media_duration_s"="Media duration (s)",
         "Image_index" = "Image index",
         "Call_type" = "Call type",
         "Observation_duration"= "Observation duration",
         "Closest_Diatance"="Closeset distance",
         "Behavioural_Category"= "Behavioral category",
         "Modifier_1"= "Modifier #1",
         "Behaviour_type"="Behavior type",
         "Media_file_name" = "Media file name",
         "Image_file_path"= "Image file path"
         )

write_csv(Trial_events_A, "E:/Individual recognition/Individual Recognition R Project/Trial_events_A.csv")

```


# clean unnecessary columns 

```{r}
# remove columns (Observation_date 2, Description 3, Observation_type 5, Source 6, FPS 8, Date 11, Time 12,Position 13, Site 15, Subject 19, Image_index 25)

# add Behaviour type (state or Point event), and phase (silence beginning, interval, silence end)
for (i in Trial_events_A) {
  
}
Trial_events_B %>% 
  select(-Observation_date,
         -Description,
         -Observation_type,
         -Source,
         -FPS,
         -Date,
         -Time,
         -Position,
         -Site,
         -Image_index,
         no_song,
         no_chase,
         no_flights)

summary(Trial_events_B)

```

#extract the total time investment of each Behaviour type (sate or point event) per individual



## DFA

```{r}

```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to
prevent printing of the R code that generated the plot.



#save workspace image
```{r}

##### saving the workspace

save.image("E:/Individual recognition/Individual Recognition R Project/Individual _Recognition_markdown_workspace_07092024.RData")

```

